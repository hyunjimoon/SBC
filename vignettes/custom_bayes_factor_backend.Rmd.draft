---
title: "Implementing custom bayes factor backends"
author: "Martin Modrák"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: yes
vignette: >
  %\VignetteIndexEntry{Implementing custom bayes factor backends}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

We assume familiraity with how Bayes factor validation with SBC works, see
`vignette("bayes_factor")` for explanation (or Modrák et al.)

## Custom BF backend



```{r}
sim_beta_binom <- function(N, shape1, shape2, two_theta = FALSE) {

  theta <- rbeta(1, shape1, shape2)
  if(two_theta){
    theta
  }

  list(
    generated = list(
      N = N,
      y = rbinom(1, size = N, prob = theta)
      ),
    variables = list(
      theta = theta
    )
  )
}

set.seed(396523)
n_sims <- 5000
ds_custom_m0 <- generate_datasets(SBC_generator_function(sim_beta_binom, N = 30, shape1 = 1, shape2 = 1), n_sims = n_sims)
ds_custom_m1 <- generate_datasets(SBC_generator_function(sim_beta_binom, N = 30, shape1 = 6, shape2 = 1), n_sims = n_sims)
ds_custom <- SBC_datasets_for_bf(ds_custom_m0, ds_custom_m1)
```

```{r}
backend_beta_binom <- function(shape1, shape2, ndraws = 5000){
  structure(list(shape1 = shape1, shape2 = shape2, ndraws = ndraws), class = "SBC_backend_beta_binom")
}

SBC_fit.SBC_backend_beta_binom <- function(backend, generated, cores) {
  draws <- rbeta(backend$ndraws, backend$shape1 + generated$y, backend$shape2 + generated$N - generated$y)
  posterior::draws_matrix("theta" = draws)
}

SBC_fit_to_bridge_sampler.SBC_backend_beta_binom <- function(backend, fit, generated, ...) {
  log_posterior_func <- function(draws.row, data) {
    dbeta(draws.row["theta"], backend$shape1, backend$shape2, log = TRUE) +
    dbinom(generated$y, size = generated$N, prob = draws.row["theta"], log = TRUE)
  }
  bridgesampling::bridge_sampler(fit, log_posterior = log_posterior_func,
                                 data = generated, lb = c("theta" = 0), ub = c("theta" = 1))
}

SBC_backend_iid_draws.SBC_backend_beta_binom <- function(backend) {
  TRUE
}

beta_binom_globals <- c("SBC_fit.SBC_backend_beta_binom", "SBC_fit_to_bridge_sampler.SBC_backend_beta_binom", "SBC_backend_iid_draws.SBC_backend_beta_binom")

backend_bs_custom <- SBC_backend_bridgesampling(
  backend_beta_binom(1, 1),
  backend_beta_binom(6, 1)
)
```


```{r}
res_custom <- compute_SBC(
  ds_custom, backend_bs_custom, globals = beta_binom_globals,
  cache_mode = "results",
  cache_location = file.path(cache_dir, "beta_binom.rds"),
  keep_fits = FALSE)

plot_ecdf_diff(res_custom)
plot_ecdf_diff(res_custom, show_hidden = TRUE)

plot_coverage_diff(res_custom, show_hidden = TRUE)

res_custom$stats
res_custom$backend_diagnostics

plot_binary_calibration_diff(res_custom$stats)
```

```{r}
hist(res_custom$backend_diagnostics$prob_H1)
```


## Custom BF for extra tests

```{r}
sim_beta_binom2 <- function(N, shape1, shape2, single_theta = TRUE) {

  theta <- rbeta(1, shape1, shape2)
  variables <- list(
      theta = theta
  )

  if(single_theta) {
    theta2 <- theta
  } else {
    theta2 <- rbeta(1, shape1, shape2)
    variables$theta2 <- theta2
  }



  list(
    generated = list(
      N = N,
      y = rbinom(2, size = N, prob = c(theta, theta2))
      ),
    variables = variables
  )
}

n_sims <- 5000
ds_custom2_m0 <- generate_datasets(SBC_generator_function(sim_beta_binom2, N = 100, shape1 = 1, shape2 = 1), n_sims = n_sims)
ds_custom2_m1 <- generate_datasets(SBC_generator_function(sim_beta_binom2, N = 100, shape1 = 1, shape2 = 1, single_theta = FALSE), n_sims = n_sims)
ds_custom2 <- SBC_datasets_for_bf(ds_custom2_m0, ds_custom2_m1)
```

```{r}
backend_beta_binom2 <- function(shape1, shape2, single_theta = TRUE, ndraws = 5000){
  structure(list(shape1 = shape1, shape2 = shape2, single_theta = single_theta, ndraws = ndraws), class = "SBC_backend_beta_binom2")
}

SBC_fit.SBC_backend_beta_binom2 <- function(backend, generated, cores) {
  if(backend$single_theta) {
    draws <- rbeta(backend$ndraws, backend$shape1 + sum(generated$y), backend$shape2 + 2 * generated$N - sum(generated$y))
    posterior::draws_matrix("theta" = draws)
  } else {
    draws1 <- rbeta(backend$ndraws, backend$shape1 + generated$y[1], backend$shape2 + generated$N - generated$y[1])
    draws2 <- rbeta(backend$ndraws, backend$shape1 + generated$y[2], backend$shape2 + generated$N - generated$y[2])
    posterior::draws_matrix("theta" = draws1, "theta2" = draws2)

  }
}

SBC_fit_to_bridge_sampler.SBC_backend_beta_binom2 <- function(backend, fit, generated, ...) {
  print(fit)
  if(backend$single_theta) {
    log_posterior_func <- function(draws.row, data) {
      log(draws.row["theta"]) + log1p(-draws.row["theta"]) +
      dbeta(draws.row["theta"], backend$shape1, backend$shape2, log = TRUE) +
      dbinom(sum(generated$y), size = 2 * generated$N, prob = draws.row["theta"], log = TRUE)
    }

    lb <- c("theta" = 0)
    ub <- c("theta" = 1)
    print(log_posterior_func(c("theta" = 0.3), generated))
  } else {
    log_posterior_func <- function(draws.row, data) {
      dbeta(draws.row["theta"], backend$shape1, backend$shape2, log = TRUE) +
      dbeta(draws.row["theta2"], backend$shape1, backend$shape2, log = TRUE) +
      dbinom(generated$y[1], size = generated$N, prob = draws.row["theta"], log = TRUE) +
        dbinom(generated$y[2], size = generated$N, prob = draws.row["theta2"], log = TRUE)
    }
    lb <-  c("theta" = 0, "theta2" = 0)
    ub <-  c("theta" = 1, "theta2" = 1)
    print(log_posterior_func(c("theta" = 0.3, "theta2" = 0.3), generated))
  }


  bs <- bridgesampling::bridge_sampler(fit, log_posterior = log_posterior_func,
                                 data = generated, lb = lb, ub = ub)

  print(bridgesampling::logml(bs))
  return(bs)
}

SBC_backend_iid_draws.SBC_backend_beta_binom2 <- function(backend) {
  TRUE
}

beta_binom2_globals <- c("SBC_fit.SBC_backend_beta_binom2", "SBC_fit_to_bridge_sampler.SBC_backend_beta_binom2", "SBC_backend_iid_draws.SBC_backend_beta_binom2")

backend_bs_custom2 <- SBC_backend_bridgesampling(
  backend_beta_binom2(1, 1),
  backend_beta_binom2(1, 1, single_theta = FALSE)
)
```


```{r}
res_custom2 <- compute_SBC(ds_custom2[1:3], backend_bs_custom2, globals = beta_binom2_globals, keep_fits = FALSE)

plot_ecdf_diff(res_custom2)
plot_ecdf_diff(res_custom2, show_hidden = TRUE)

res_custom2$stats
res_custom2$backend_diagnostics
```

```{r}
res_custom2$outputs %>% purrr::walk(\(x) { cat("=======\n"); cat(x, sep = "\n")})
```


```{r}
hist(res_custom2$backend_diagnostics$prob_H1)
plot_coverage_diff(res_custom2, show_hidden = TRUE)

```


```{r}
dm <- SBC_fit_to_draws_matrix( res_custom2$fits[[3]])
as.numeric(dm[,"theta2"]) %>% is.na() %>% sum()
```


```{r}
res_custom2$default_diagnostics
```

