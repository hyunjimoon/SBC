---
title: "self-calibration-adaptive"
author: "Hyunji Moon, Shinyoung Kim"
output:
  html_document: default
  pdf_document: default
---
```{r setup, include=FALSE, warning=FALSE}
library(SBC)
library(cmdstanr)
library(parallel)
library(bayesplot)
library(posterior)
library(dplyr)
library(rstan)
library(future)
library(ggpubr)
library(rstanarm)
library(ggplot2)
library(mclust)
library(plot3D)
library(nloptr)
options(mc.cores = parallel::detectCores())
plan(multisession)
options(SBC.min_chunk_size = 5)
#set.seed(1984)
```


```{R, warning=FALSE, error=FALSE}
## Generator settings
# number of SBC simulations per iteration (generator)
nsims <- 200

# number of observations
nobs <- 10#2

# link function (1 = logit, 2 = probit, 3 = cloglog)
link <- 1

# number of binomial trials per observation
nsize <- 10

## Backend settings
# number of draws per posterior approximation 
ndraws <- 1000

# number of chains for hmc posterior approximation
nchains <- 2
```

# Inspecting DAP of binom-laplace 
```{R, warning=FALSE, error=FALSE}
generator_binom <- function(lambdas, fixed_args){
  # fixed value across simulated datasets
  # experiment settings
  nobs <- fixed_args$nobs
  nsize <- fixed_args$nsize
  dist_types <- fixed_args$dist_types
  # modular settings
  link_type <- fixed_args$link_type
  
  # generate
  lambda_arg1 <- c()
  lambda_arg2 <- c()
  if(dist_types$eta == "normal"){
    eta <- rnorm(1, mean = lambdas$eta$mu, sd=lambdas$eta$sigma)
    lambda_arg1 <- c(lambda_arg1, lambdas$eta$mu)
    lambda_arg2 <- c(lambda_arg2, lambdas$eta$sigma)
  }
  else if(dist_types$eta == "gamma"){
    eta <- rgamma(1, shape = lambdas$eta$alpha, rate = lambdas$eta$beta)
    lambda_arg1 <- c(lambda_arg1, lambdas$eta$alpha)
    lambda_arg2 <- c(lambda_arg2, lambdas$eta$beta)
  }
  
  
    
  mu <- invtf_param_vec(eta, link_type = link_type)
  Y <- rbinom(nobs, size = nsize, prob = mu) 
  list(
    parameters = list(eta = eta),
    generated = list(nobs= nobs, nsize = nsize, link = link_type,
                     dist_types = match(unlist(dist_types), c("normal", "gamma")), lambda_arg1 = lambda_arg1, lambda_arg2 = lambda_arg2, 
                     Y = Y)
  )
}

fixed_args_binom <- list(nobs = nobs, nsize = nsize, link_type = 1, nsims = nsims, ndraws = ndraws, dist_types=list(eta="normal"))

```

```{R, warning=FALSE, error=FALSE}
# initial prior hyperparameters
lambda_init_binom <- list(
  eta = list(mu=100, sigma=100)
)
datasets_binom <- generate_datasets(SBC_generator_function(generator_binom, lambda_init_binom, fixed_args_binom), n_datasets = fixed_args_binom$nsims)

# hyperparameter update algorithm 
updator = "mc_update"

# maximal number of SBC iterations
niter <- 100

# tolerance
tol <- 0.1

# learning rate
gamma <- 1.5 # 0.5 for gradient update, 10 for normal_str_update

# step2: inferring posterior
rstan_binom_mod <- stan_model("models/binom-laplace.stan")
cmdstan_binom_mod <- cmdstanr::cmdstan_model("models/binom-laplace.stan")

backend_binom_opt <- SBC_backend_rstan_optimizing(rstan_binom_mod, draws = ndraws)
backend_binom_hmc <- SBC_backend_cmdstan_sample(cmdstan_binom_mod, chains = 4, iter_sampling = ndraws / 4) # thin = 10
calib_generator <- function(lambdas, fixed_args){
  generate_datasets(SBC_generator_function(generator_binom, lambdas, fixed_args), n_datasets = fixed_args$nsims)
}

calculate_dap <- function(mu, var, generator, backened, fixed_args){
  lambda_init_binom <- list(
    eta = list(mu=mu, sigma=sqrt(var))
  )
  datasets <- do.call(generator, list(lambda_init_binom, fixed_args = fixed_args))
  sbc_result <- compute_results(datasets, backened, thin_ranks = 1)
  draws_eta <- c()
  draws_Y <- c()
  prior_thetas <- posterior::extract_variable(datasets$parameters, "eta")
  var_theta_tilde_bar <- 0
  var_theta_tilde <- 0
  theta_bar <- mean(prior_thetas)
  for(i in 1:nsims){
    draws_Y <- c(draws_Y, datasets$generated[[i]]$Y)
    samples <- SBC_fit_to_draws_matrix(sbc_result$fits[[i]])
    etas <- posterior::extract_variable(samples, "eta")
    draws_eta <- c(draws_eta, etas)
    
    var_theta_tilde_bar <- var_theta_tilde_bar + (mean(draws_eta) - mean(prior_thetas))^2
    var_theta_tilde <- var_theta_tilde + sum((draws_eta - mean(draws_eta))^2)
  }
  
  var_theta_tilde_bar <- var_theta_tilde_bar / fixed_args$nsims
  var_theta_tilde <- var_theta_tilde / (fixed_args$nsims * ndraws)
  # assume normal for dap
  mu <- mean(draws_eta)
  #var <- sd(draws_eta)^2
  var <- 100
  
  return(list(mu=mu, var=var, draws_eta=draws_eta, draws_Y=draws_Y, var_theta_tilde_bar=var_theta_tilde_bar, var_theta_tilde=var_theta_tilde, theta_bar=theta_bar))
}
```

##

```{r}
gridsize_mu <- 2
gridsize_var <- 2
mu_seq <- seq(1, 5, length.out = gridsize_mu)
var_seq <- seq(1, 5, length.out = gridsize_var)
grid_size <- length(mu_seq) * length(var_seq)

squared_lambda_diff <- array(rep(NA, grid_size), dim = c(gridsize_mu, gridsize_var))
rownames(squared_lambda_diff) <- mu_seq
colnames(squared_lambda_diff) <- var_seq

lambda_diff <- array(rep(NA, grid_size), dim = c(gridsize_mu, gridsize_var))
rownames(lambda_diff) <- mu_seq
colnames(lambda_diff) <- var_seq

dap_lambda_mu <- array(rep(NA, grid_size), dim = c(gridsize_mu, gridsize_var))
dap_lambda_var <- array(rep(NA, grid_size), dim = c(gridsize_mu, gridsize_var))
rownames(dap_lambda_mu) <- mu_seq
rownames(dap_lambda_var) <- mu_seq
colnames(dap_lambda_mu) <- var_seq
colnames(dap_lambda_var) <- var_seq

lambda_mu <- array(rep(NA, grid_size), dim = c(gridsize_mu, gridsize_var))
lambda_var <- array(rep(NA, grid_size), dim = c(gridsize_mu, gridsize_var))
rownames(lambda_mu) <- mu_seq
rownames(lambda_var) <- mu_seq
colnames(lambda_mu) <- var_seq
colnames(lambda_var) <- var_seq

var_theta_tilde_bar <- array(rep(NA, grid_size), dim = c(gridsize_mu, gridsize_var))
var_theta_tilde <- array(rep(NA, grid_size), dim = c(gridsize_mu, gridsize_var))
rownames(var_theta_tilde_bar) <- mu_seq
rownames(var_theta_tilde_bar) <- mu_seq
colnames(var_theta_tilde) <- var_seq
colnames(var_theta_tilde) <- var_seq

theta_bar <- array(rep(NA, grid_size), dim = c(gridsize_mu, gridsize_var))
rownames(theta_bar) <- mu_seq
rownames(theta_bar) <- mu_seq

generated_Y <- array(rep(NA, nsims * nobs * gridsize * gridsize), dim=c(nsims * nobs, gridsize_mu, gridsize_var) )
dimnames(generated_Y)[[2]] <- mu_seq
dimnames(generated_Y)[[3]] <- var_seq
for(j in 1:length(var_seq)){
  for(i in 1:length(mu_seq)){
    dap <- calculate_dap(mu_seq[[i]],var_seq[[j]] , calib_generator, backend_binom_opt, fixed_args_binom)
    squared_lambda_diff[i,j] <- sqrt((mu_seq[[i]] - dap$mu)^2 + (var_seq[[j]] - dap$var)^2)
    lambda_diff[i,j] <- (dap$mu - mu_seq[[i]]) + (dap$var - var_seq[[j]])
    dap_lambda_mu[i, j] <- dap$mu
    dap_lambda_var[i, j] <- dap$var
    lambda_mu[i, j] <- mu_seq[[i]]
    lambda_var[i, j] <- var_seq[[j]]
    generated_Y[, i, j] <- dap$draws_Y
    var_theta_tilde_bar[i, j] <- dap$var_theta_tilde_bar
    var_theta_tilde[i, j] <- dap$var_theta_tilde
    theta_bar[i, j] <- dap$theta_bar
  }
}
```


```{R}
persp3D(x=mu_seq, y=var_seq, z = contraction_arr, theta=55, phi=10, xlab="mu", ylab="var", zlab="convex if ", ticks=5, ticktype="detailed")

```

```{R}
for(j in 1:length(var_seq)){
  for(i in 1:length(mu_seq)){
    print(sprintf("mu: %f var: %f", lambda_mu[i, j], lambda_var[i, j]))
    bias_term <- sum((theta_bar[i, j] - lambda_mu[i, j])^2)
    var_term_1 <- sum(var_theta_tilde_bar[i, j])
    var_term_2 <- sum(var_theta_tilde[i, j])
    total <- bias_term + var_term_1 + var_term_2
    print(sprintf("term1: %f term2: %f term3: %f total: %f", bias_term / total, var_term_1 / total, var_term_2 /total, total))
  }
}
```


Define objective and constraint functions

```{R}
# maximize entropy
# partial derivative is: -log p_w - 1
calc_entropy <- function(p){
  return(as.numeric((p + 1e-8) %*% -log(p + 1e-8)) - 100 * (sum(p) - 1)^2)
}

calc_entropy_grad <- function(p){
  return(-log(p + 1e-8) - 1 - 200 * (p + 1e-8))
}

# equal to minimize negative entropy
neg_entropy <- function(p){
  return(-calc_entropy(p))
}

neg_entropy_grad <- function(p){
  return(-calc_entropy_grad(p))
}

theta <- 14
# partial derivative is contraction_arr_{w}
p_v_product_constraint <- function(p){
  # equality constraint should equal 0
  return(as.numeric(p %*% as.vector(contraction_arr)) - 6)
}

p_v_product_constraint_grad <- function(p){
  return(as.vector(contraction_arr))
}

# calculate theta and p_init
# start at uniform
p_init <- as.numeric(c(rep(1e-8, grid_size - 1), 1))

prob_ineq_constraints <- function(p){
  # constraints <- c(p_v_product_constraint(p), probability_simplex_constraint(p))
  # grad <- c(p_v_product_constraint_grad(p), probability_simplex_constraint_grad(p))
  constraints <- c(p_v_product_constraint(p))
  grad <- c(p_v_product_constraint_grad(p))
  return( list(constraints=constraints, jacobian=grad) )
}

#If you want to use equality constraints, then you should use one of these algorithms NLOPT_LD_AUGLAG, NLOPT_LN_AUGLAG, NLOPT_LD_AUGLAG_EQ, NLOPT_LN_AUGLAG_EQ, NLOPT_GN_ISRES, NLOPT_LD_SLSQP

probability_simplex_opts <- list(algorithm="NLOPT_LD_SLSQP", print_level=3, xtol_rel=1e-8, maxeval=1000)
prob_lb <- rep(0.0, length(p_init))
prob_ub <- rep(1.0, length(p_init))
prob_opt <- nloptr::nloptr(p_init, 
                           neg_entropy, 
                           eval_grad_f = neg_entropy_grad, 
                           eval_g_ineq = prob_ineq_constraints, 
                           opts = probability_simplex_opts, 
                           lb=prob_lb, ub=prob_ub)
```

```{R}

result_out <- array(prob_opt$solution, dim = c(length(mu_seq), length(var_seq)))
rownames(result_out) <- mu_seq
colnames(result_out) <- var_seq
persp3D(x=mu_seq, y=var_seq, z = result_out, theta=55, phi=10, xlab="mu", ylab="var", zlab="prob_opt_result", ticks=5, ticktype="detailed")
persp3D(x=mu_seq, y=var_seq, z = contraction_arr, theta=25, phi=10, xlab="mu", ylab="var", zlab="convex if ", ticks=5, ticktype="detailed")
```

```{R}
N = 10000
sampled_probs <- sample(1:grid_size, N, prob=as.vector(result_out), replace=TRUE)
mu <- rep(mu_seq, length(var_seq))
sigma <- rep(var_seq, each=length(mu_seq))
combined <- data.frame(mu=mu, sigma=sigma)
thetas <- c()
for(i in 1:N){
  thetas[i] <- rnorm(1, combined[sampled_probs[i], "mu"], combined[sampled_probs[i], "sigma"])
}
hist(thetas, probability=TRUE, breaks=30)
```
